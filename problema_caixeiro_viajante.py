# -*- coding: utf-8 -*-
"""Problema_Caixeiro_Viajante.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ejKKv7QnnFXWWnORFUUg-_5Uk6nvNPWV
"""

pip install deap

import random
import array
import numpy as np 
import matplotlib.pyplot as plt
from deap import creator, base, tools, algorithms

matrizDistancia = [ # 0 1  2   3   4  5   6   7  8   9   10  11  12  13  14  15
                     [0,40,77,288,216,26,104,54,255,234,132,347,295,382,310,469],           #Araranguá       0       
                     [40,0,65,236,205,67,93,104,266,285,121,333,280,367,268,416],           #Criciuma        1     
                     [77,65,0,213,141,103,29,139,329,321,57,269,217,303,245,391],           #Tubarão         2      
                     [288,236,213,0,227,285,235,321,217,343,263,223,304,314,129,179],       #Lages           3       
                     [216,205,141,227,0,243,123,279,447,462,94,146,100,186,195,410],        #Floripa         4         
                     [26,67,103,285,243,0,129,38,229,220,157,369,317,404,333,461],          #Sombrio         5      
                     [104,93,29,235,123,129,0,166,357,348,38,249,197,284,268,416],          #Laguna          6    
                     [54,104,139,321,279,38,166,0,201,193,193,405,353,440,369,497],         #Torres          7  
                     [255,266,329,217,447,229,357,201,0,127,379,440,521,531,346,394],       #Caxias do Sul   8  
                     [234,285,321,343,462,220,348,193,127,0,383,568,542,629,474,479],       #Porto Alegre    9  
                     [132,121,57,263,94,157,38,193,379,383,0,220,167,254,242,444],          #Imbituba       10  
                     [347,333,269,223,146,369,249,405,440,568,220,0,58,103,100,302],        #Blumenau       11 
                     [295,280,217,304,100,317,197,353,521,542,167,58,0,93,152,354],         #Itajai         12 
                     [382,367,303,314,186,404,284,440,531,629,254,103,93,0,188,326],        #Joinville      13 
                     [310,268,245,129,195,333,268,369,346,474,242,100,152,188,0,204],       #Rio do Sul     14 
                     [469,416,391,179,410,461,416,497,394,479,444,302,354,326,204,0],       #Caçador        15
                ]
tamanho = 16

creator.create("FitnessMin", base.Fitness, weights=(-1.0,)) #Função de Minimização com um único objetivo (obter menor distância)
creator.create("Individual", array.array, typecode='i', fitness=creator.FitnessMin) #cria a estrutura do indivíduo

toolbox = base.Toolbox() #registra todos os elementos na toolbox
toolbox.register("genes", random.sample, range(tamanho), tamanho)  #os genes são os indices das cidades


toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.genes) # inicializa os individuos com a estrutura criada e os genes(indices) criados acima
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

def evalPCV(individual):
    distancia = matrizDistancia[individual[-1]][individual[0]] #Calcula a volta para origem
    for gene1, gene2 in zip(individual[0:-1],individual[1:]):
        distancia += matrizDistancia[gene1][gene2]             #Percorre toda a lista para calcular distancia do trajeto
    return distancia,

toolbox.register("mate", tools.cxPartialyMatched) #crossover,  cxPartialyMatched troca no sentido do pai1 para o pai2 e depois no sentido inverso, para evitar genes repetidos
toolbox.register("mutate", tools.mutShuffleIndexes, indpb=0.1) #mutação Order-Based-Mutation de 10% de chance de ocorrer a mutação em um determinado gene (troca o elemento da posição i com o elemento da posição j) mutShuffleIndexes: Shuffle the attributes of the input individual and return the mutant. The individual is expected to be a sequence. The indpb argument is the probability of each attribute to be moved. Usually this mutation is applied on vector of indices.
toolbox.register("select", tools.selTournament, tournsize=2) #Seleção por torneio, selecionando um grupo k de indivíduos aleatórios menor que a população, após a seleção seleciona aquele que possui a melhor aptidão dentre esses k (k é o nro de elementos que vai compor o torneio)
toolbox.register("evaluate", evalPCV)                        #aptidão, menor caminho

def main():
    random.seed(15)
    pop = toolbox.population(n=200) #população
    hof = tools.HallOfFame(1) #salva em uma lista o melhor indivíduo da população
    stats = tools.Statistics(lambda ind: ind.fitness.values) #salvando as aptidões de cada indivíduo para calcular as estatísticas depois
    stats.register("mean", np.mean) #média
    stats.register("std", np.std) #desvio padrão
    stats.register("min", np.min) #mínimo 
    stats.register("max", np.max) #máximo

    result,log = algorithms.eaSimple(pop, toolbox, cxpb=0.7, mutpb=0.1, ngen=500, stats=stats, halloffame=hof, verbose=True) # pop = população / toolbox = registro de todas as definições que criei de mutação, seleção, etc / probabilidade de crossover = 70% / mutação = 20% / numero de gerações = 500 /  estatísticas / 

    return pop,stats,hof,result,log

if __name__ == "__main__":
    pop,stats,hof,result,log=main()
    print("\nO melhor indivíduo é: ", hof)
    print("\n Menor distância: ",evalPCV(hof[0]))

menores = log.select('min')
maiores = log.select('max')
media = log.select('mean')

plt.plot(menores, label="Menores")
plt.plot(maiores, label="Maiores")
plt.plot(media, label="Media")
plt.xlabel("Geração")
plt.ylabel("Aptidão")
plt.legend(loc=1)